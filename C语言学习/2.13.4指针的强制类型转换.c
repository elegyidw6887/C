/*
指针的强制类型转换
*/

//#include<stdio.h>
//#include<stdlib.h>
//
//int main(void)
//{
//	/*
//	
//	强转指针类型/强转地址类型
//		当指针（也就是地址）的数据类型被改变了之后，指针的读写以及计算方式也会随之发生改变，同时要注意越界情况
//		例1：
//			>int a;
//			>double* p1 = (double*)&a;
//			>*p1 = 12.3;
//			在运行之后会出现越界异常提示，而且是在程序运行结束之后出现提醒，4字节->8字节转换，越界
//
//	*/
//	int a = 12;
//	float* p1 = (float*)&a;
//	*p1 = 12.3f;
//	//测试之后并无任何问题，因为int与float均为4字节空间，未越界
//
//	double d = 12.3;
//	int* p2 = (int*)&d;
//	*p2 = 23;
//	//测试之后也并没有出现问题，因为double有8字节，而int只有4字节，因此在转换后的空间甚至都无法被int全部使用，未越界，但是可能影响到原始数据
//	printf("%f,%d\n", d, *p2);
//	*(p2 + 1) = 24;
//	//由于double的变量d共有8字节，而int只占用4字节，还剩余4字节，这个时候让指针+1（+一个类型的字节量），就可以对后面的4个字节进行操作
//	printf("%d\n", *(p2 + 1));
//	//由此可以展示出指针操作的灵活性
//	*(int*)((short*)p2 + 1) = 25;
//	printf("%d,%d,%d\n", *p2, *(p2 + 1), *(int*)((short*)p2 + 1));
//	//通过对指针的类型通过来回转换，来做到对地址的零活操作，此操作实现了对8字节空间中的中间4字节进行操作
//	*(int*)((char*)p2 + 2) = 26;
//	printf("%d,%d,%d\n", *p2, *(p2 + 1), *(int*)((char*)p2 + 2));
//	//换一种强转换方式也能够完美实现
//
//	/*
//	
//	由于指针操作上的灵活性，极其容易出错，要多加小心
//
//	指针/地址的类型【决定着】指针/地址的读写方式（本质上是字节数）
//	
//	*/
//
//
//
//	system("pause");
//	return 0;
//}