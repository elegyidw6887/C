/*
大小端存储的区别
*/

//#include<stdio.h>
//#include<stdlib.h>
//
//union Storage
//{
//	int i;
//	char c[4];
//	//使用联合体的特性来测试大小端存储，由于联合的特性，直接省略了强转换的步骤
//};
//
//int main(void)
//{
//	/*
//	
//	计算机存储数据的方式：
//		大端存储
//			数据的高位存储在内存的高位（高位地址）
//			（多见于网络）
//			注：
//				>数据的高位存在于数据的左侧
//				>内存的高位存在于内存的右侧
//				>二者的方向相反
//
//		小端存储
//			数据的高位存储在内存的低位（低位地址）
//			（多见于计算机）
//
//		一个特殊的数字
//			134480385
//			0000 1000 0000 0100 0000 0010 0000 0001（四段不相同的二进制数组成）
//	
//	*/
//	int i = 134480385;
//	char* p = (char*)&i;
//	printf("%p,%d\n%p,%d\n%p,%d\n%p,%d\n", &p[0], p[0], &p[1], p[1], &p[2], p[2], &p[3], p[3]);
//	/*
//		0000 1000 > 8
//		0000 0100 > 4
//		0000 0010 > 2
//		0000 0001 > 1
//
//	测试可得计算机存储为小端存储
//	*/
//	printf("\n");
//
//	int temp;
//	temp = p[0];
//	p[0] = p[3];
//	p[3] = temp;
//
//	temp = p[1];
//	p[1] = p[2];
//	p[2] = temp;
//	printf("%p,%d\n%p,%d\n%p,%d\n%p,%d\n", &p[0], p[0], &p[1], p[1], &p[2], p[2], &p[3], p[3]);
//	printf("%d\n", i);
//	/*
//
//	通过中间临时变量来把小端存储的形式转换为大端存储，可以直接再使用网络进行发送，但是在转换结束之后，原始数据在本地就被改变了
//	*/
//	printf("\n");
//
//	union Storage LS = { 134480385 };
//	printf("%p,%d\n%p,%d\n%p,%d\n%p,%d\n", &LS.c[0], LS.c[0], &LS.c[1], LS.c[1], &LS.c[2], LS.c[2], &LS.c[3], LS.c[3]);
//	//输出结果一致，只有地址不相同，存储形式为大端存储
//
//
//	system("pause");
//	return 0;
//}